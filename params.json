{"body":"\r\nNode.js - batchflow\r\n===================\r\n\r\n[![build status](https://secure.travis-ci.org/jprichardson/node-batchflow.png)](http://travis-ci.org/jprichardson/node-batchflow)\r\n\r\nBatch process collections in parallel or sequentially.\r\n\r\n\r\nWhy?\r\n----\r\n\r\nI really got tired of writing the following patterns over and over again:\r\n\r\n**Sequential:**\r\n\r\n```javascript\r\nvar files = [... list of files ...];\r\nfunction again(x) {\r\n\tif (x < files.length) {\r\n\t\tfs.readFile(files[x], function(err, data) {\r\n\t\t\t//... do something with data ...\r\n\t\t\tagain(x + 1);\r\n\t\t});\r\n\t} else {\r\n\t\tconsole.log('Done.');\r\n\t}\r\n}\r\n\r\nagain(0);\r\n```\r\n\r\nor..\r\n\r\n**Parallel:**\r\n\r\n```javascript\r\nvar files = [... list of files ...];\r\nvar pending = 0;\r\nfiles.forEach(function(file, i) {\r\n\tpending += 1;\r\n\tfs.readFile(file, function(err, data) {\r\n\t\t//... do something with data ....\r\n\t\t\r\n\t\tpending -= 1;\r\n\t\tif (pending === 0 && i === files.length -1) {\r\n\t\t\tconsole.log('Done.');\r\n\t\t}\r\n\t});\r\n});\r\n```\r\n\r\nThat's ugly. For more complicated examples it requires a bit more thinking.\r\n\r\nWhy don't I use the wonderful library [async][1]? Well, `async` tries to do way too much. I also suffer from a severe case of NIH syndrome. Kidding, or else I'd rewrite Express.js. Or, am I? Muahahhaa. `async` syntax is also very ugly and not CoffeeScript friendly.\r\n\r\n\r\n\r\n\r\nInstallation\r\n------------\r\n\r\n    npm install batchflow\r\n\r\n\r\n\r\nExamples\r\n--------\r\n\r\n### 50 Foot Overview\r\n\r\nSimple Sequential Example:\r\n\r\n```javascript\r\nvar a = [\r\n        function(finished) { setTimeout(function(){finished(1)}, 1); }, //executes in 1 ms\r\n        function(finished) { setTimeout(function(){finished(2)}, 20); }, //executes in 20 ms\r\n        function(finished) { setTimeout(function(){finished(3)}, 2); } //executes in 2 ms\r\n    ];\r\n\r\n//sequential\r\nbatch(a).sequential()\r\n.each(function(i, item, done) {\r\n  item(done);\r\n}).end(function(results) {\r\n  for (var i = 0; i < results.length; ++i) {\r\n    console.log(results[i]);\r\n  }\r\n});\r\n\r\n/*\r\n  1\r\n  2\r\n  3\r\n*/\r\n```\r\n\r\nSimple Parallel Example:\r\n\r\n```javascript\r\n//parallel\r\nbatch(a).parallel()\r\n.each(function(i, item, done) {\r\n  item(done);\r\n}).end(function(results) {\r\n  for (var i = 0; i < results.length; ++i) {\r\n    console.log(results[i]);\r\n  }\r\n});\r\n\r\n/*\r\n  1\r\n  3\r\n  2\r\n*/\r\n```\r\n\r\n### Arrays\r\n\r\nLet's rewrite the previous file patterns mentioned in **Why?** into a sequential example:\r\n\r\n**Sequential:**\r\n\r\n```javascript\r\nvar batch = require('batchflow');\r\n\r\nvar files = [... list of files ...];\r\nbatch(files).sequential()\r\n.each(function(i, item, next) {\r\n\tfs.readFile(item, function(err, data) {\r\n\t\t//do something with data\r\n\t\tnext(someResult);\r\n\t});\r\n}).end(function(results) {\r\n\t//analyze results\r\n});\r\n```\r\n\r\nHow about the parallel example?\r\n\r\n**Parallel:**\r\n \r\n ```javascript\r\nvar batch = require('batchflow');\r\n\r\nvar files = [... list of files ...];\r\nbatch(files).parallel()\r\n.each(function(i, item, done) {\r\n\tfs.readFile(item, function(err, data) {\r\n\t\t//do something with data\r\n\t\tdone(someResult); //<---- yes, you must still call done() in parallel, this way we can know when to trigger `end()`.\r\n\t});\r\n}).end(function(results) {\r\n\t//analyze results\r\n});\r\n```\r\n\r\nWhat's that, your data is not stored in an array? Oh, you say it's stored in an object? That's OK too...\r\n\r\n### Objects\r\n\r\n**Sequential:**\r\n\r\n```javascript\r\nvar batch = require('batchflow');\r\n\r\nvar files = {'file1': 'path'.... 'filen': 'pathn'}\r\nbatch(files).sequential()\r\n.each(function(key, val, next) {\r\n\tfs.readFile(val, function(err, data) {\r\n\t\t//do something with data\r\n\t\tnext(someResult);\r\n\t});\r\n}).end(function(results) {\r\n\t//analyze results\r\n});\r\n```\r\n\r\nHow about the parallel example?\r\n\r\n**Parallel:**\r\n\r\n ```javascript\r\nvar batch = require('batchflow');\r\n\r\nvar files = {'file1': 'path'.... 'filen': 'pathn'}\r\nbatch(files).parallel()\r\n.each(function(key, val, done) {\r\n\tfs.readFile(val, function(err, data) {\r\n\t\t//do something with data\r\n\t\tdone(someResult);\r\n\t});\r\n}).end(function(results) {\r\n\t//analyze results\r\n});\r\n```\r\n\r\n### Misc\r\n\r\n1. Is `sequential()` or `parallel()` too long? Fine. `series()` and `seq()` are aliases for `sequential()`. `par()` is an alias for `parallel()`.\r\n2. You don't like the fluent API? That's OK too:\r\n\r\nNon-fluent API BatchFlow\r\n\r\n```javascript\r\nvar batch = require('batchflow');\r\nvar bf = batch(files);\r\nbf.sequential()\r\n\r\nbf.each(function(i, file, next) {\r\n\tnext(someResult);\r\n});\r\n \r\nbf.end(function(results) {\r\n\t//blah blah\r\n});\r\n```\r\n\r\n\r\n### CoffeeScript Friendly\r\n\r\n```coffee\r\nbatch = require('batchflow')\r\nfiles = [... list of files ...]\r\nbf = batch(files).seq().each (i, file, done) ->\r\n  fs.readFile file, done\r\nbf.error (err) ->\r\n  console.log(err);\r\nbf.end (results) ->\r\n  console.log fr.toString() for fr in results\r\n```\r\n\r\n\r\n### Error Handling\r\n\r\nWhat's that, you want error handling? Well, you might as well call me Burger King... have it your way.\r\n\r\nNote that before version `0.3`, it would exit prematurely if an error happened. This was a boneheaded\r\ndesign decision. After `0.3`, it'll keep happily processing even if an error occured.\r\n\r\nCatch an error in the callback parameter...\r\n\r\n```javascript\r\nvar a = {'f': '/tmp/file_DOES_NOT_exist_hopefully' + Math.random()};\r\nbatch(a).parallel().each(function(i, item, done) {\r\n  fs.readFile(item, done);\r\n}).error(function(err) {\r\n  console.error(err);\r\n}).end(function(fileData) {\r\n  //do something with file data\r\n});\r\n```\r\n\r\nCatch an error in the function...\r\n\r\n```javascript\r\nvar a = ['/tmp/file_DOES_NOT_exist_hopefully' + Math.random()];\r\nbatch(a).series().each(function(i, item, done) {\r\n  throw new Error('err');\r\n}).error(function(err) {\r\n  console.error(err);\r\n}).end(function() {\r\n  //do something\r\n});\r\n\r\n```\r\n\r\n\r\n### Limits\r\n\r\nYou can set a limit to how many items can be processed in parallel. In fact, `sequential` mode is the same as having the `limit` set to `1` and calling `parallel`. In other words: `batch(myArray).sequential() ....` is the same as `batch(myArray).parallel(1)`.\r\n\r\nTo set the limit, just pass the limit as a parameter to `parallel()`. The **default is 2^53** which is the max integer size in JavaScript.\r\n\r\nExample:\r\n\r\n```javascript\r\nbatch(myArray).parallel(8)\r\n.each(function(i, item, done){\r\n  // ... code here ... \r\n}).end(function(results){\r\n  // ... code here ...\r\n})\r\n```\r\n\r\n\r\n### Difference between done() and next()\r\n\r\nSo you noticed that in all of the examples where I was calling `sequential()` the third parameter is named `next` and in the examples where I was calling `parallel()` the third parameter is named `done`?  This is really just a matter of convention. It could be named `fruitypebbles`. But in sequential processing, it makes sense for it to be `next` because you want to process the next one. However, in parallel processing, you want to alert the system that the callback is `done`.\r\n\r\nSequential...\r\n\r\n```javascript\r\nbatch(myArray).sequential()\r\n.each(function(i, item, next) {\r\n  // ... code here ...\r\n}).end();\r\n```\r\n\r\nParallel...\r\n\r\n```javascript\r\nbatch(myArray).parallel()\r\n.each(function(i, item, done) {\r\n  // ... code here ...\r\n}).end();\r\n```\r\n\r\n\r\n### Progress\r\n\r\nYou can keep track of progress by accessing the `finished` field.\r\n\r\nCompute percentage by this formula: `(this.finished / this.total) * 100.0`.\r\n\r\nExample:\r\n\r\n```javascript\r\nvar myar = {w: 'hi', b: 'hello', c: 'hola', z: 'gutentag'}\r\nbatch(myar).sequential()\r\n.each(function(i, item, next) {\r\n  console.log(this.finished) //the number finished.\r\n  console.log(this.total) //4\r\n  console.log((this.finished / this.total) * 100.0) //{percent complete}\r\n})\r\n.end();\r\n```\r\n\r\n\r\nAuthor\r\n------\r\n\r\n`node-batchflow` was written by [JP Richardson][aboutjp]. You should follow him on Twitter [@jprichardson][twitter]. Also read his coding blog [Procbits][procbits]. If you write software with others, you should checkout [Gitpilot][gitpilot] to make collaboration with Git simple.\r\n\r\n\r\n\r\nLicense\r\n-------\r\n\r\n(MIT License)\r\n\r\nCopyright 2012, JP  <jprichardson@gmail.com>\r\n\r\n\r\n\r\n[1]: https://github.com/caolan/async/\r\n\r\n[aboutjp]: http://about.me/jprichardson\r\n[twitter]: http://twitter.com/jprichardson\r\n[procbits]: http://procbits.com\r\n[gitpilot]: http://gitpilot.com\r\n\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Batch process collections in parallel or sequentially.","google":"","name":"Node-batchflow"}